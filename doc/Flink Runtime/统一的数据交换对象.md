# 统一的数据交换对象
- 在Flink的执行引擎中，流动的元素主要有两种：缓冲（Buffer）和事件（Event）。**Buffer主要针对用户数据交换**，
  而**Event则用于一些特殊的控制标识**。但在实现时，为了在通信层统一数据交换，Flink提供了数据交换对象——**BufferOrEvent**。
  它是一个既可以表示Buffer又可以表示Event的类。上层使用者只需调用isBuffer和isEvent方法即可判断当前收到的这条数据是
  Buffer还是Event。
  

## Buffer: 对MemorySegment的封装，为了对基于引用计数的Buffer回收机制提供支持
- 缓冲（Buffer）是数据交换的载体，几乎所有的数据（当然事件是特殊的）交换都需要经过Buffer。**Buffer底层依赖于
  Flink自管理内存的内存段（MemorySegment）作为数据的容器**。Buffer在内存段上做了一层封装，这一层封装是**为了对
  基于引用计数的Buffer回收机制提供支持**。



## Event
- 1、Flink的数据流中不仅仅只有用户的数据，还包含了一些特殊的事件，**这些事件都是由算子注入到数据流中的。
     它们在每个流分区里伴随着其他的数据元素而被有序地分发。接收到这些事件的算子会对这些事件给出响应**，
     典型的事件类型有：
  - 1、检查点屏障：用于隔离多个检查点之间的数据，保障快照数据的一致性；
  - 2、迭代屏障：标识流分区已到达了一个超级步的结尾；
  - 3、子分区数据结束标记：当消费任务获取到该事件时，表示其所消费的对应的分区中的数据已被全部消费完成；
  
- 2、事件假设一个流分区维持着元素顺序。鉴于此，在Flink中一源算子在消费单一流分区时，能够保证FIFO（先进先出）的元素顺序。
     而为了保证流处理的速率同时避免反压，**算子有时会接收超过一个流分区的元素并将它们合并**。综合各种场景，Flink中的数据流在
     任何形式的重分区或广播之后不提供顺序保证。而对无序元素的处理任务交给算子自行实现。

- 3、在Flink中所有事件的最终基类都是AbstractEvent。AbstractEvent这一抽象类又派生出另一个抽象类RuntimeEvent，几乎所有
     预先内置的事件都直接派生于此。除了预定义的事件外，Flink还支持自定义的扩展事件，所有自定义的事件都继承自派生于
     AbstractEvent的TaskEvent。总结一下，其类继承关系图如下：
     ![](/home/yuan/quickstart/doc/pic/Event-class-diagram.png)